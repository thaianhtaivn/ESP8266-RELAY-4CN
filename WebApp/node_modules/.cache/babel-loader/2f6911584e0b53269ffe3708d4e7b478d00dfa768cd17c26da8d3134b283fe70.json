{"ast":null,"code":"'use strict';\n\nvar tls = require('tls');\nvar debug = require('debug')('mqttjs:tls');\nfunction buildBuilder(mqttClient, opts) {\n  var connection;\n  opts.port = opts.port || 8883;\n  opts.host = opts.hostname || opts.host || 'localhost';\n  opts.servername = opts.host;\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n  delete opts.path;\n  debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized);\n  connection = tls.connect(opts);\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'));\n    } else {\n      connection.removeListener('error', handleTLSerrors);\n    }\n  });\n  function handleTLSerrors(err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err);\n    }\n\n    // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n    connection.end();\n  }\n  connection.on('error', handleTLSerrors);\n  return connection;\n}\nmodule.exports = buildBuilder;","map":{"version":3,"names":["tls","require","debug","buildBuilder","mqttClient","opts","connection","port","host","hostname","servername","rejectUnauthorized","path","connect","on","authorized","emit","Error","removeListener","handleTLSerrors","err","end","module","exports"],"sources":["/Users/thaitai/Desktop/Work/IoT/relay-web-app/node_modules/mqtt/lib/connect/tls.js"],"sourcesContent":["'use strict'\nvar tls = require('tls')\nvar debug = require('debug')('mqttjs:tls')\n\nfunction buildBuilder (mqttClient, opts) {\n  var connection\n  opts.port = opts.port || 8883\n  opts.host = opts.hostname || opts.host || 'localhost'\n  opts.servername = opts.host\n\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\n\n  delete opts.path\n\n  debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized)\n\n  connection = tls.connect(opts)\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'))\n    } else {\n      connection.removeListener('error', handleTLSerrors)\n    }\n  })\n\n  function handleTLSerrors (err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err)\n    }\n\n    // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n    connection.end()\n  }\n\n  connection.on('error', handleTLSerrors)\n  return connection\n}\n\nmodule.exports = buildBuilder\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AACxB,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC;AAE1C,SAASE,YAAYA,CAAEC,UAAU,EAAEC,IAAI,EAAE;EACvC,IAAIC,UAAU;EACdD,IAAI,CAACE,IAAI,GAAGF,IAAI,CAACE,IAAI,IAAI,IAAI;EAC7BF,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACI,QAAQ,IAAIJ,IAAI,CAACG,IAAI,IAAI,WAAW;EACrDH,IAAI,CAACK,UAAU,GAAGL,IAAI,CAACG,IAAI;EAE3BH,IAAI,CAACM,kBAAkB,GAAGN,IAAI,CAACM,kBAAkB,KAAK,KAAK;EAE3D,OAAON,IAAI,CAACO,IAAI;EAEhBV,KAAK,CAAC,uCAAuC,EAAEG,IAAI,CAACE,IAAI,EAAEF,IAAI,CAACG,IAAI,EAAEH,IAAI,CAACM,kBAAkB,CAAC;EAE7FL,UAAU,GAAGN,GAAG,CAACa,OAAO,CAACR,IAAI,CAAC;EAC9B;EACAC,UAAU,CAACQ,EAAE,CAAC,eAAe,EAAE,YAAY;IACzC,IAAIT,IAAI,CAACM,kBAAkB,IAAI,CAACL,UAAU,CAACS,UAAU,EAAE;MACrDT,UAAU,CAACU,IAAI,CAAC,OAAO,EAAE,IAAIC,KAAK,CAAC,oBAAoB,CAAC,CAAC;IAC3D,CAAC,MAAM;MACLX,UAAU,CAACY,cAAc,CAAC,OAAO,EAAEC,eAAe,CAAC;IACrD;EACF,CAAC,CAAC;EAEF,SAASA,eAAeA,CAAEC,GAAG,EAAE;IAC7B;IACA,IAAIf,IAAI,CAACM,kBAAkB,EAAE;MAC3BP,UAAU,CAACY,IAAI,CAAC,OAAO,EAAEI,GAAG,CAAC;IAC/B;;IAEA;IACA;IACA;IACA;IACA;IACAd,UAAU,CAACe,GAAG,EAAE;EAClB;EAEAf,UAAU,CAACQ,EAAE,CAAC,OAAO,EAAEK,eAAe,CAAC;EACvC,OAAOb,UAAU;AACnB;AAEAgB,MAAM,CAACC,OAAO,GAAGpB,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}