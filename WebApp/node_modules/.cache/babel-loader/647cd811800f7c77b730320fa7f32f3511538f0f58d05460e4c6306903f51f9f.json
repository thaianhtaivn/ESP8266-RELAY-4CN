{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Store = require('./store');\nvar mqttPacket = require('mqtt-packet');\nvar Writable = require('readable-stream').Writable;\nvar inherits = require('inherits');\nvar reInterval = require('reinterval');\nvar validations = require('./validations');\nvar xtend = require('xtend');\nvar debug = require('debug')('mqttjs:client');\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback);\n};\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nvar socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND'];\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nvar errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\nfunction sendPacket(client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet);\n  debug('sendPacket :: emitting `packetsend`');\n  client.emit('packetsend', packet);\n  debug('sendPacket :: writing to stream');\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n  debug('sendPacket :: writeToStream result %s', result);\n  if (!result && cb) {\n    debug('sendPacket :: handle events on `drain` once through callback.');\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    debug('sendPacket :: invoking cb');\n    cb();\n  }\n}\nfunction flush(queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!queue);\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\nfunction flushVolatile(queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n  client.outgoingStore.put(packet, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\nfunction nop(error) {\n  debug('nop ::', error);\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient(streamBuilder, options) {\n  var k;\n  var that = this;\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n  this.options = options || {};\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n  debug('MqttClient :: options.protocol', options.protocol);\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n  debug('MqttClient :: options.username', options.username);\n  debug('MqttClient :: options.keepalive', options.keepalive);\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  debug('MqttClient :: clientId', this.options.clientId);\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder;\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store();\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {};\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {};\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null;\n  // Is the client connected?\n  this.connected = false;\n  // Are we disconnecting?\n  this.disconnecting = false;\n  // Packet queue\n  this.queue = [];\n  // connack timer\n  this.connackTimer = null;\n  // Reconnect timer\n  this.reconnectTimer = null;\n  // Is processing store?\n  this._storeProcessing = false;\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {};\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535));\n\n  // Inflight callbacks\n  this.outgoing = {};\n\n  // True if connection is first time.\n  this._firstConnection = true;\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue;\n    function deliver() {\n      var entry = queue.shift();\n      debug('deliver :: entry %o', entry);\n      var packet = null;\n      if (!entry) {\n        return;\n      }\n      packet = entry.packet;\n      debug('deliver :: call _sendPacket for %o', packet);\n      that._sendPacket(packet, function (err) {\n        if (entry.cb) {\n          entry.cb(err);\n        }\n        deliver();\n      });\n    }\n    debug('connect :: sending queued packets');\n    deliver();\n  });\n  this.on('close', function () {\n    debug('close :: connected set to `false`');\n    this.connected = false;\n    debug('close :: clearing connackTimer');\n    clearTimeout(this.connackTimer);\n    debug('close :: clearing ping timer');\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n    debug('close :: calling _setupReconnect');\n    this._setupReconnect();\n  });\n  EventEmitter.call(this);\n  debug('MqttClient :: setting up stream');\n  this._setupStream();\n}\ninherits(MqttClient, EventEmitter);\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket;\n  var that = this;\n  var writable = new Writable();\n  var parser = mqttPacket.parser(this.options);\n  var completeParse = null;\n  var packets = [];\n  debug('_setupStream :: calling method to clear reconnect');\n  this._clearReconnect();\n  debug('_setupStream :: using streamBuilder provided to client to create stream');\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.');\n    packets.push(packet);\n  });\n  function nextTickWork() {\n    if (packets.length) {\n      process.nextTick(work);\n    } else {\n      var done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n  function work() {\n    debug('work :: getting next packet in queue');\n    var packet = packets.shift();\n    if (packet) {\n      debug('work :: packet pulled from queue');\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      debug('work :: no packets in queue');\n      var done = completeParse;\n      completeParse = null;\n      debug('work :: done flag is %s', !!done);\n      if (done) done();\n    }\n  }\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    debug('writable stream :: parsing buffer');\n    parser.parse(buf);\n    work();\n  };\n  function streamErrorHandler(error) {\n    debug('streamErrorHandler :: error', error.message);\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error');\n      that.emit('error', error);\n    } else {\n      nop(error);\n    }\n  }\n  debug('_setupStream :: pipe stream to writable stream');\n  this.stream.pipe(writable);\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler);\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId);\n    flushVolatile(that.outgoing);\n    debug('stream: emit close to MqttClient');\n    that.emit('close');\n  });\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`');\n  connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n  // avoid message queue\n  sendPacket(this, connectPacket);\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'));\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n      return this;\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      var authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\nMqttClient.prototype._handlePacket = function (packet, done) {\n  var options = this.options;\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n  debug('_handlePacket :: emitting packetreceive');\n  this.emit('packetreceive', packet);\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n      break;\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n      done();\n      break;\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n      break;\n    case 'connack':\n      this._handleConnack(packet);\n      done();\n      break;\n    case 'pingresp':\n      this._handlePingresp(packet);\n      done();\n      break;\n    case 'disconnect':\n      this._handleDisconnect(packet);\n      done();\n      break;\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n  return this.disconnecting;\n};\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic);\n  var packet;\n  var options = this.options;\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  // default opts\n  var defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  };\n  if (options.protocolVersion === 5) {\n    packet.properties = opts.properties;\n    if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum || !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n      /*\n      if we are don`t setup topic alias or\n      topic alias maximum less than topic alias or\n      server don`t give topic alias maximum,\n      we are removing topic alias from packet\n      */\n      delete packet.properties.topicAlias;\n    }\n  }\n  debug('publish :: qos', opts.qos);\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = {\n        volatile: false,\n        cb: callback || nop\n      };\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled');\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n        this._storePacket(packet, undefined, opts.cbStorePut);\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n        this._sendPacket(packet, undefined, opts.cbStorePut);\n      }\n      break;\n    default:\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled');\n        this._storePacket(packet, callback, opts.cbStorePut);\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n        this._sendPacket(packet, callback, opts.cbStorePut);\n      }\n      break;\n  }\n  return this;\n};\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet;\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n  var subs = [];\n  var obj = args.shift();\n  var resubscribe = obj.resubscribe;\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n  var invalidTopic;\n  var that = this;\n  var version = this.options.protocolVersion;\n  delete obj.resubscribe;\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n  invalidTopic = validations.validateTopics(obj);\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true');\n    return this;\n  }\n  var defaultOpts = {\n    qos: 0\n  };\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n  opts = xtend(defaultOpts, opts);\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic);\n      if (!that._resubscribeTopics.hasOwnProperty(topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        var currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      debug('subscribe: object topic %s', k);\n      if (!that._resubscribeTopics.hasOwnProperty(k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        var currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n        debug('subscribe: pushing `%s` to subs list', currentOpts);\n        subs.push(currentOpts);\n      }\n    });\n  }\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  };\n  if (opts.properties) {\n    packet.properties = opts.properties;\n  }\n  if (!subs.length) {\n    callback(null, []);\n    return;\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    debug('subscribe :: resubscribe true');\n    var topics = [];\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        var topic = {\n          qos: sub.qos\n        };\n        if (version === 5) {\n          topic.nl = sub.nl || false;\n          topic.rap = sub.rap || false;\n          topic.rh = sub.rh || 0;\n          topic.properties = sub.properties;\n        }\n        that._resubscribeTopics[sub.topic] = topic;\n        topics.push(sub.topic);\n      }\n    });\n    that.messageIdToTopic[packet.messageId] = topics;\n  }\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: function (err, packet) {\n      if (!err) {\n        var granted = packet.granted;\n        for (var i = 0; i < granted.length; i += 1) {\n          subs[i].qos = granted[i];\n        }\n      }\n      callback(err, subs);\n    }\n  };\n  debug('subscribe :: call _sendPacket');\n  this._sendPacket(packet);\n  return this;\n};\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  };\n  var that = this;\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n  var topic = args.shift();\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic];\n  } else if (Array.isArray(topic)) {\n    packet.unsubscriptions = topic;\n  }\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic];\n    });\n  }\n  if (typeof opts === 'object' && opts.properties) {\n    packet.properties = opts.properties;\n  }\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: callback\n  };\n  debug('unsubscribe: call _sendPacket');\n  this._sendPacket(packet);\n  return this;\n};\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  var that = this;\n  debug('end :: (%s)', this.options.clientId);\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n  debug('end :: cb? %s', !!cb);\n  cb = cb || nop;\n  function closeStores() {\n    debug('end :: closeStores: closing incoming and outgoing stores');\n    that.disconnected = true;\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        debug('end :: closeStores: emitting end');\n        that.emit('end');\n        if (cb) {\n          debug('end :: closeStores: invoking callback with args');\n          cb();\n        }\n      });\n    });\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores');\n      // var boundProcess = process.nextTick.bind(null, closeStores)\n      process.nextTick(closeStores.bind(that));\n    }, opts);\n  }\n  if (this.disconnecting) {\n    cb();\n    return this;\n  }\n  this._clearReconnect();\n  this.disconnecting = true;\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n    finish();\n  }\n  return this;\n};\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  delete this.outgoing[messageId];\n  this.outgoingStore.del({\n    messageId: messageId\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect');\n  var that = this;\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n    that._reconnect();\n  };\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n  return this;\n};\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client');\n  this.emit('reconnect');\n  debug('_reconnect: calling _setupStream');\n  this._setupStream();\n};\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this;\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state');\n      this.emit('offline');\n      debug('_setupReconnect :: set `reconnecting` to `true`');\n      this.reconnecting = true;\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!');\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  } else {\n    debug('_setupReconnect :: doing nothing...');\n  }\n};\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer');\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  var opts = arguments[2];\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close');\n    this.stream.on('close', done);\n  }\n  debug('_cleanUp :: forced? %s', forced);\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n    this.stream.destroy();\n  } else {\n    var packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n    this._clearReconnect();\n    this._setupReconnect();\n  }\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer');\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n  cbStorePut = cbStorePut || nop;\n  if (!this.connected) {\n    debug('_sendPacket :: client not connected. Storing packet offline.');\n    this._storePacket(packet, cb, cbStorePut);\n    return;\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval();\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n    /* falls through */\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n};\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet);\n  debug('_storePacket :: cb? %s', !!cb);\n  cbStorePut = cbStorePut || nop;\n\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n    this.queue.push({\n      packet: packet,\n      cb: cb\n    });\n  } else if (packet.qos > 0) {\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n    this.outgoingStore.put(packet, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n  var that = this;\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...');\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n    this.pingResp = false;\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true');\n    this._cleanUp(true);\n  }\n};\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack');\n  var options = this.options;\n  var version = options.protocolVersion;\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n      this._shiftPingInterval();\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n  if (rc === 0) {\n    this.reconnecting = false;\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet);\n  done = typeof done !== 'undefined' ? done : nop;\n  var topic = packet.topic.toString();\n  var message = packet.payload;\n  var qos = packet.qos;\n  var messageId = packet.messageId;\n  var that = this;\n  var options = this.options;\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n  debug('_handlePublish: qos %d', qos);\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n          if (error) {\n            return that.emit('error', error);\n          }\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: messageId\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n          if (error) {\n            return that.emit('error', error);\n          }\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.');\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var messageId = packet.messageId;\n  var type = packet.cmd;\n  var response = null;\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  var that = this;\n  var err;\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.');\n    // Server sent an ack in error, ignore it.\n    return;\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type);\n  switch (type) {\n    case 'pubcomp':\n    // same thing as puback for QoS 2\n    case 'puback':\n      var pubackRC = packet.reasonCode;\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC]);\n        err.code = pubackRC;\n        cb(err, packet);\n      }\n      delete this.outgoing[messageId];\n      this.outgoingStore.del(packet, cb);\n      break;\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      };\n      var pubrecRC = packet.reasonCode;\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC]);\n        err.code = pubrecRC;\n        cb(err, packet);\n      } else {\n        this._sendPacket(response);\n      }\n      break;\n    case 'suback':\n      delete this.outgoing[messageId];\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          var topics = this.messageIdToTopic[messageId];\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic];\n            });\n          }\n        }\n      }\n      cb(null, packet);\n      break;\n    case 'unsuback':\n      delete this.outgoing[messageId];\n      cb(null);\n      break;\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet');\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  var messageId = packet.messageId;\n  var that = this;\n  var comp = {\n    cmd: 'pubcomp',\n    messageId: messageId\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        that.incomingStore.del(pub, nop);\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++;\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1;\n  }\n  return id;\n};\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return this.nextId === 1 ? 65535 : this.nextId - 1;\n};\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function (connack) {\n  debug('_resubscribe');\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5');\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          var resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n  this._firstConnection = false;\n};\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n  var that = this;\n  this._setupPingTimer();\n  this._resubscribe(packet);\n  this.connected = true;\n  function startStreamProcess() {\n    var outStore = that.outgoingStore.createStream();\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n      clearStoreProcessing();\n    }\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n      that._storeProcessing = true;\n      var packet = outStore.read(1);\n      var cb;\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status);\n            }\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n        that._sendPacket(packet);\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n    outStore.on('end', function () {\n      var allProcessed = true;\n      for (var id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  }\n  // start flowing\n  startStreamProcess();\n};\nmodule.exports = MqttClient;","map":{"version":3,"names":["EventEmitter","require","Store","mqttPacket","Writable","inherits","reInterval","validations","xtend","debug","setImmediate","global","callback","process","nextTick","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","socketErrors","errors","defaultId","Math","random","toString","substr","sendPacket","client","packet","cb","emit","result","writeToStream","stream","options","once","flush","queue","Object","keys","forEach","messageId","Error","flushVolatile","volatile","storeAndSend","cbStorePut","cmd","outgoingStore","put","storedPacket","err","nop","error","MqttClient","streamBuilder","k","that","protocol","username","rejectUnauthorized","clientId","customHandleAcks","arguments","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","nextId","max","floor","outgoing","_firstConnection","on","deliver","entry","shift","_sendPacket","clearTimeout","clear","_setupReconnect","call","_setupStream","prototype","connectPacket","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","length","work","done","_handlePacket","_write","buf","enc","parse","streamErrorHandler","message","includes","code","pipe","create","bind","properties","authenticationMethod","authenticationData","end","authPacket","reasonCode","setMaxListeners","setTimeout","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","topic","opts","defaultOpts","qos","retain","dup","payload","_nextId","topicAlias","topicAliasMaximum","_storePacket","subscribe","args","Array","i","subs","obj","pop","invalidTopic","version","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscriptions","topics","sub","granted","unsubscribe","unsubscriptions","force","closeStores","disconnected","close","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","validReasonCodes","indexOf","handleMessage","type","response","pubackRC","pubrecRC","grantedI","comp","get","pub","id","getLastMessageId","_resubscribe","connack","_resubscribeTopicsKeys","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","storeDeliver","read","status","allProcessed","module","exports"],"sources":["/Users/thaitai/Desktop/Work/IoT/relay-web-app/node_modules/mqtt/lib/client.js"],"sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\nvar EventEmitter = require('events').EventEmitter\nvar Store = require('./store')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar debug = require('debug')('mqttjs:client')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nvar socketErrors = [\n  'ECONNREFUSED',\n  'EADDRINUSE',\n  'ECONNRESET',\n  'ENOTFOUND'\n]\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nvar errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet)\n  debug('sendPacket :: emitting `packetsend`')\n  client.emit('packetsend', packet)\n\n  debug('sendPacket :: writing to stream')\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options)\n  debug('sendPacket :: writeToStream result %s', result)\n  if (!result && cb) {\n    debug('sendPacket :: handle events on `drain` once through callback.')\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    debug('sendPacket :: invoking cb')\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!(queue))\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction flushVolatile (queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    cbStorePut()\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop (error) {\n  debug('nop ::', error)\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol)\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\n  debug('MqttClient :: options.username', options.username)\n  debug('MqttClient :: options.keepalive', options.keepalive)\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\n\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\n\n  debug('MqttClient :: clientId', this.options.clientId)\n\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store()\n  this.incomingStore = options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // Is processing store?\n  this._storeProcessing = false\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {}\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // True if connection is first time.\n  this._firstConnection = true\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      debug('deliver :: entry %o', entry)\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n      debug('deliver :: call _sendPacket for %o', packet)\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    debug('connect :: sending queued packets')\n    deliver()\n  })\n\n  this.on('close', function () {\n    debug('close :: connected set to `false`')\n    this.connected = false\n\n    debug('close :: clearing connackTimer')\n    clearTimeout(this.connackTimer)\n\n    debug('close :: clearing ping timer')\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n\n    debug('close :: calling _setupReconnect')\n    this._setupReconnect()\n  })\n  EventEmitter.call(this)\n\n  debug('MqttClient :: setting up stream')\n  this._setupStream()\n}\ninherits(MqttClient, EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  debug('_setupStream :: calling method to clear reconnect')\n  this._clearReconnect()\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.')\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    if (packets.length) {\n      process.nextTick(work)\n    } else {\n      var done = completeParse\n      completeParse = null\n      done()\n    }\n  }\n\n  function work () {\n    debug('work :: getting next packet in queue')\n    var packet = packets.shift()\n\n    if (packet) {\n      debug('work :: packet pulled from queue')\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      debug('work :: no packets in queue')\n      var done = completeParse\n      completeParse = null\n      debug('work :: done flag is %s', !!(done))\n      if (done) done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    debug('writable stream :: parsing buffer')\n    parser.parse(buf)\n    work()\n  }\n\n  function streamErrorHandler (error) {\n    debug('streamErrorHandler :: error', error.message)\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error')\n      that.emit('error', error)\n    } else {\n      nop(error)\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream')\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler)\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId)\n    flushVolatile(that.outgoing)\n    debug('stream: emit close to MqttClient')\n    that.emit('close')\n  })\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`')\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() =>\n        this.emit('error', new Error('Packet has no Authentication Method')\n        ))\n      return this\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      var authPacket = xtend({cmd: 'auth', reasonCode: 0}, this.options.authPacket)\n      sendPacket(this, authPacket)\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  var options = this.options\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\n    this.end({reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' }})\n    return this\n  }\n  debug('_handlePacket :: emitting packetreceive')\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    case 'disconnect':\n      this._handleDisconnect(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic)\n  var packet\n  var options = this.options\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  if (options.protocolVersion === 5) {\n    packet.properties = opts.properties\n    if ((!options.properties && packet.properties && packet.properties.topicAlias) || ((opts.properties && options.properties) &&\n      ((opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum) ||\n        (!options.properties.topicAliasMaximum && opts.properties.topicAlias)))) {\n      /*\n      if we are don`t setup topic alias or\n      topic alias maximum less than topic alias or\n      server don`t give topic alias maximum,\n      we are removing topic alias from packet\n      */\n      delete packet.properties.topicAlias\n    }\n  }\n\n  debug('publish :: qos', opts.qos)\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = {\n        volatile: false,\n        cb: callback || nop\n      }\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled')\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false\n        this._storePacket(packet, undefined, opts.cbStorePut)\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        this._sendPacket(packet, undefined, opts.cbStorePut)\n      }\n      break\n    default:\n      if (this._storeProcessing) {\n        debug('_storeProcessing enabled')\n        this._storePacket(packet, callback, opts.cbStorePut)\n      } else {\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        this._sendPacket(packet, callback, opts.cbStorePut)\n      }\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = new Array(arguments.length)\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n  var version = this.options.protocolVersion\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true')\n    return this\n  }\n\n  var defaultOpts = {\n    qos: 0\n  }\n  if (version === 5) {\n    defaultOpts.nl = false\n    defaultOpts.rap = false\n    defaultOpts.rh = 0\n  }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic)\n      if (!that._resubscribeTopics.hasOwnProperty(topic) ||\n        that._resubscribeTopics[topic].qos < opts.qos ||\n          resubscribe) {\n        var currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        }\n        if (version === 5) {\n          currentOpts.nl = opts.nl\n          currentOpts.rap = opts.rap\n          currentOpts.rh = opts.rh\n          currentOpts.properties = opts.properties\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\n        subs.push(currentOpts)\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        debug('subscribe: object topic %s', k)\n        if (!that._resubscribeTopics.hasOwnProperty(k) ||\n          that._resubscribeTopics[k].qos < obj[k].qos ||\n            resubscribe) {\n          var currentOpts = {\n            topic: k,\n            qos: obj[k].qos\n          }\n          if (version === 5) {\n            currentOpts.nl = obj[k].nl\n            currentOpts.rap = obj[k].rap\n            currentOpts.rh = obj[k].rh\n            currentOpts.properties = opts.properties\n          }\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\n          subs.push(currentOpts)\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (opts.properties) {\n    packet.properties = opts.properties\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    debug('subscribe :: resubscribe true')\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        var topic = { qos: sub.qos }\n        if (version === 5) {\n          topic.nl = sub.nl || false\n          topic.rap = sub.rap || false\n          topic.rh = sub.rh || 0\n          topic.properties = sub.properties\n        }\n        that._resubscribeTopics[sub.topic] = topic\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: function (err, packet) {\n      if (!err) {\n        var granted = packet.granted\n        for (var i = 0; i < granted.length; i += 1) {\n          subs[i].qos = granted[i]\n        }\n      }\n\n      callback(err, subs)\n    }\n  }\n  debug('subscribe :: call _sendPacket')\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n  var args = new Array(arguments.length)\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  var topic = args.shift()\n  var callback = args.pop() || nop\n  var opts = args.pop()\n\n  if (typeof topic === 'string') {\n    topic = [topic]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (Array.isArray(topic)) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  if (typeof opts === 'object' && opts.properties) {\n    packet.properties = opts.properties\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: callback\n  }\n\n  debug('unsubscribe: call _sendPacket')\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  var that = this\n\n  debug('end :: (%s)', this.options.clientId)\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop\n    opts = force\n    force = false\n    if (typeof opts !== 'object') {\n      cb = opts\n      opts = null\n      if (typeof cb !== 'function') {\n        cb = nop\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts\n    opts = null\n  }\n\n  debug('end :: cb? %s', !!cb)\n  cb = cb || nop\n\n  function closeStores () {\n    debug('end :: closeStores: closing incoming and outgoing stores')\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        debug('end :: closeStores: emitting end')\n        that.emit('end')\n        if (cb) {\n          debug('end :: closeStores: invoking callback with args')\n          cb()\n        }\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores')\n      // var boundProcess = process.nextTick.bind(null, closeStores)\n      process.nextTick(closeStores.bind(that))\n    }, opts)\n  }\n\n  if (this.disconnecting) {\n    cb()\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  delete this.outgoing[messageId]\n  this.outgoingStore.del({messageId: messageId}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect')\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client')\n  this.emit('reconnect')\n  debug('_reconnect: calling _setupStream')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state')\n      this.emit('offline')\n      debug('_setupReconnect :: set `reconnecting` to `true`')\n      this.reconnecting = true\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!')\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  } else {\n    debug('_setupReconnect :: doing nothing...')\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer')\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  var opts = arguments[2]\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close')\n    this.stream.on('close', done)\n  }\n\n  debug('_cleanUp :: forced? %s', forced)\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\n    this.stream.destroy()\n  } else {\n    var packet = xtend({ cmd: 'disconnect' }, opts)\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\n    this._sendPacket(\n      packet,\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer')\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\n  cbStorePut = cbStorePut || nop\n\n  if (!this.connected) {\n    debug('_sendPacket :: client not connected. Storing packet offline.')\n    this._storePacket(packet, cb, cbStorePut)\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\n}\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet)\n  debug('_storePacket :: cb? %s', !!cb)\n  cbStorePut = cbStorePut || nop\n\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n    this.queue.push({ packet: packet, cb: cb })\n  } else if (packet.qos > 0) {\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null\n    this.outgoingStore.put(packet, function (err) {\n      if (err) {\n        return cb && cb(err)\n      }\n      cbStorePut()\n    })\n  } else if (cb) {\n    cb(new Error('No connection to broker'))\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...')\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true')\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack')\n  var options = this.options\n  var version = options.protocolVersion\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  clearTimeout(this.connackTimer)\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive\n      this._shiftPingInterval()\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this._onConnect(packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet)\n  done = typeof done !== 'undefined' ? done : nop\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var messageId = packet.messageId\n  var that = this\n  var options = this.options\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\n  debug('_handlePublish: qos %d', qos)\n  switch (qos) {\n    case 2: {\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\n        if (code) {\n          that._sendPacket({cmd: 'pubrec', messageId: messageId, reasonCode: code}, done)\n        } else {\n          that.incomingStore.put(packet, function () {\n            that._sendPacket({cmd: 'pubrec', messageId: messageId}, done)\n          })\n        }\n      })\n      break\n    }\n    case 1: {\n      // emit the message event\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\n        if (!code) { that.emit('message', topic, message, packet) }\n        that.handleMessage(packet, function (err) {\n          if (err) {\n            return done && done(err)\n          }\n          that._sendPacket({cmd: 'puback', messageId: messageId, reasonCode: code}, done)\n        })\n      })\n      break\n    }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.')\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var messageId = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  var that = this\n  var err\n\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type)\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      var pubackRC = packet.reasonCode\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC])\n        err.code = pubackRC\n        cb(err, packet)\n      }\n      delete this.outgoing[messageId]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      }\n      var pubrecRC = packet.reasonCode\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC])\n        err.code = pubrecRC\n        cb(err, packet)\n      } else {\n        this._sendPacket(response)\n      }\n      break\n    case 'suback':\n      delete this.outgoing[messageId]\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          var topics = this.messageIdToTopic[messageId]\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic]\n            })\n          }\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[messageId]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet')\n  callback = typeof callback !== 'undefined' ? callback : nop\n  var messageId = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: messageId}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.incomingStore.del(pub, nop)\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet)\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function (connack) {\n  debug('_resubscribe')\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n  if (!this._firstConnection &&\n      (this.options.clean || (this.options.protocolVersion === 5 && !connack.sessionPresent)) &&\n      _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5')\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          var resubscribeTopic = {}\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\n          resubscribeTopic.resubscribe = true\n          this.subscribe(resubscribeTopic, {properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties})\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      }\n    } else {\n      this._resubscribeTopics = {}\n    }\n  }\n\n  this._firstConnection = false\n}\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet)\n    return\n  }\n\n  var that = this\n\n  this._setupPingTimer()\n  this._resubscribe(packet)\n\n  this.connected = true\n\n  function startStreamProcess () {\n    var outStore = that.outgoingStore.createStream()\n\n    function clearStoreProcessing () {\n      that._storeProcessing = false\n      that._packetIdsDuringStoreProcessing = {}\n    }\n\n    that.once('close', remove)\n    outStore.on('error', function (err) {\n      clearStoreProcessing()\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n      clearStoreProcessing()\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n      that._storeProcessing = true\n\n      var packet = outStore.read(1)\n\n      var cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver()\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n        }\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\n        that._sendPacket(packet)\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    outStore.on('end', function () {\n      var allProcessed = true\n      for (var id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false\n          break\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing()\n        that.removeListener('close', remove)\n        that.emit('connect', packet)\n      } else {\n        startStreamProcess()\n      }\n    })\n    storeDeliver()\n  }\n  // start flowing\n  startStreamProcess()\n}\n\nmodule.exports = MqttClient\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}